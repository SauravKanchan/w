/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/eth-sig-util@3.0.1/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&__createBinding(t,e,r);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.recoverTypedSignature_v4=exports.recoverTypedSignature=exports.signTypedData_v4=exports.signTypedData=exports.recoverTypedMessage=exports.signTypedMessage=exports.getEncryptionPublicKey=exports.decryptSafely=exports.decrypt=exports.encryptSafely=exports.encrypt=exports.recoverTypedSignatureLegacy=exports.signTypedDataLegacy=exports.typedSignatureHash=exports.extractPublicKey=exports.recoverPersonalSignature=exports.personalSign=exports.normalize=exports.concatSig=exports.TypedDataUtils=exports.TYPED_MESSAGE_SCHEMA=void 0;const ethUtil=__importStar(require("ethereumjs-util")),ethAbi=__importStar(require("ethereumjs-abi")),nacl=__importStar(require("tweetnacl")),naclUtil=__importStar(require("tweetnacl-util")),TYPED_MESSAGE_SCHEMA={type:"object",properties:{types:{type:"object",additionalProperties:{type:"array",items:{type:"object",properties:{name:{type:"string"},type:{type:"string"}},required:["name","type"]}}},primaryType:{type:"string"},domain:{type:"object"},message:{type:"object"}},required:["types","primaryType","domain","message"]};exports.TYPED_MESSAGE_SCHEMA=TYPED_MESSAGE_SCHEMA;const TypedDataUtils={encodeData(e,t,r,n=!0){const i=["bytes32"],o=[this.hashType(e,r)];if(n){const a=(e,t,i)=>{if(void 0!==r[t])return["bytes32",null==i?"0x0000000000000000000000000000000000000000000000000000000000000000":ethUtil.keccak(this.encodeData(t,i,r,n))];if(void 0===i)throw new Error(`missing value for field ${e} of type ${t}`);if("bytes"===t)return["bytes32",ethUtil.keccak(i)];if("string"===t)return"string"==typeof i&&(i=Buffer.from(i,"utf8")),["bytes32",ethUtil.keccak(i)];if(t.lastIndexOf("]")===t.length-1){const r=t.slice(0,t.lastIndexOf("[")),n=i.map((t=>a(e,r,t)));return["bytes32",ethUtil.keccak(ethAbi.rawEncode(n.map((([e])=>e)),n.map((([,e])=>e))))]}return[t,i]};for(const n of r[e]){const[e,r]=a(n.name,n.type,t[n.name]);i.push(e),o.push(r)}}else for(const a of r[e]){let e=t[a.name];if(void 0!==e)if("bytes"===a.type)i.push("bytes32"),e=ethUtil.keccak(e),o.push(e);else if("string"===a.type)i.push("bytes32"),"string"==typeof e&&(e=Buffer.from(e,"utf8")),e=ethUtil.keccak(e),o.push(e);else if(void 0!==r[a.type])i.push("bytes32"),e=ethUtil.keccak(this.encodeData(a.type,e,r,n)),o.push(e);else{if(a.type.lastIndexOf("]")===a.type.length-1)throw new Error("Arrays are unimplemented in encodeData; use V4 extension");i.push(a.type),o.push(e)}}return ethAbi.rawEncode(i,o)},encodeType(e,t){let r="",n=this.findTypeDependencies(e,t).filter((t=>t!==e));n=[e].concat(n.sort());for(const e of n){if(!t[e])throw new Error("No type definition specified: "+e);r+=`${e}(${t[e].map((({name:e,type:t})=>`${t} ${e}`)).join(",")})`}return r},findTypeDependencies(e,t,r=[]){if([e]=e.match(/^\w*/u),r.includes(e)||void 0===t[e])return r;r.push(e);for(const n of t[e])for(const e of this.findTypeDependencies(n.type,t,r))!r.includes(e)&&r.push(e);return r},hashStruct(e,t,r,n=!0){return ethUtil.keccak(this.encodeData(e,t,r,n))},hashType(e,t){return ethUtil.keccak(this.encodeType(e,t))},sanitizeData(e){const t={};for(const r in TYPED_MESSAGE_SCHEMA.properties)e[r]&&(t[r]=e[r]);return"types"in t&&(t.types=Object.assign({EIP712Domain:[]},t.types)),t},sign(e,t=!0){const r=this.sanitizeData(e),n=[Buffer.from("1901","hex")];return n.push(this.hashStruct("EIP712Domain",r.domain,r.types,t)),"EIP712Domain"!==r.primaryType&&n.push(this.hashStruct(r.primaryType,r.message,r.types,t)),ethUtil.keccak(Buffer.concat(n))}};function concatSig(e,t,r){const n=ethUtil.fromSigned(t),i=ethUtil.fromSigned(r),o=ethUtil.bufferToInt(e),a=padWithZeroes(ethUtil.toUnsigned(n).toString("hex"),64),s=padWithZeroes(ethUtil.toUnsigned(i).toString("hex"),64),c=ethUtil.stripHexPrefix(ethUtil.intToHex(o));return ethUtil.addHexPrefix(a.concat(s,c)).toString("hex")}function normalize(e){if(e){if("number"==typeof e){const t=ethUtil.toBuffer(e);e=ethUtil.bufferToHex(t)}if("string"!=typeof e){let t="eth-sig-util.normalize() requires hex string or integer input.";throw t+=` received ${typeof e}: ${e}`,new Error(t)}return ethUtil.addHexPrefix(e.toLowerCase())}}function personalSign(e,t){const r=ethUtil.toBuffer(t.data),n=ethUtil.hashPersonalMessage(r),i=ethUtil.ecsign(n,e);return ethUtil.bufferToHex(concatSig(i.v,i.r,i.s))}function recoverPersonalSignature(e){const t=getPublicKeyFor(e),r=ethUtil.publicToAddress(t);return ethUtil.bufferToHex(r)}function extractPublicKey(e){return"0x"+getPublicKeyFor(e).toString("hex")}function externalTypedSignatureHash(e){const t=typedSignatureHash(e);return ethUtil.bufferToHex(t)}function signTypedDataLegacy(e,t){const r=typedSignatureHash(t.data),n=ethUtil.ecsign(r,e);return ethUtil.bufferToHex(concatSig(n.v,n.r,n.s))}function recoverTypedSignatureLegacy(e){const t=recoverPublicKey(typedSignatureHash(e.data),e.sig),r=ethUtil.publicToAddress(t);return ethUtil.bufferToHex(r)}function encrypt(e,t,r){switch(r){case"x25519-xsalsa20-poly1305":{if("string"!=typeof t.data)throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ');const r=nacl.box.keyPair();let n;try{n=naclUtil.decodeBase64(e)}catch(e){throw new Error("Bad public key")}const i=naclUtil.decodeUTF8(t.data),o=nacl.randomBytes(nacl.box.nonceLength),a=nacl.box(i,o,n,r.secretKey);return{version:"x25519-xsalsa20-poly1305",nonce:naclUtil.encodeBase64(o),ephemPublicKey:naclUtil.encodeBase64(r.publicKey),ciphertext:naclUtil.encodeBase64(a)}}default:throw new Error("Encryption type/version not supported")}}function encryptSafely(e,t,r){const{data:n}=t;if(!n)throw new Error("Cannot encrypt empty msg.data");if("object"==typeof n&&"toJSON"in n)throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");const i={data:n,padding:""},o=Buffer.byteLength(JSON.stringify(i),"utf-8")%2048;let a=0;o>0&&(a=2048-o-16),i.padding="0".repeat(a);return encrypt(e,{data:JSON.stringify(i)},r)}function decrypt(e,t){switch(e.version){case"x25519-xsalsa20-poly1305":{const r=nacl_decodeHex(t),n=nacl.box.keyPair.fromSecretKey(r).secretKey,i=naclUtil.decodeBase64(e.nonce),o=naclUtil.decodeBase64(e.ciphertext),a=naclUtil.decodeBase64(e.ephemPublicKey),s=nacl.box.open(o,i,a,n);let c;try{c=naclUtil.encodeUTF8(s)}catch(e){throw new Error("Decryption failed.")}if(c)return c;throw new Error("Decryption failed.")}default:throw new Error("Encryption type/version not supported.")}}function decryptSafely(e,t){return JSON.parse(decrypt(e,t)).data}function getEncryptionPublicKey(e){const t=nacl_decodeHex(e),r=nacl.box.keyPair.fromSecretKey(t).publicKey;return naclUtil.encodeBase64(r)}function signTypedMessage(e,t,r="V4"){switch(r){case"V1":return signTypedDataLegacy(e,t);case"V3":return signTypedData(e,t);case"V4":default:return signTypedData_v4(e,t)}}function recoverTypedMessage(e,t="V4"){switch(t){case"V1":return recoverTypedSignatureLegacy(e);case"V3":return recoverTypedSignature(e);case"V4":default:return recoverTypedSignature_v4(e)}}function signTypedData(e,t){const r=TypedDataUtils.sign(t.data,!1),n=ethUtil.ecsign(r,e);return ethUtil.bufferToHex(concatSig(n.v,n.r,n.s))}function signTypedData_v4(e,t){const r=TypedDataUtils.sign(t.data),n=ethUtil.ecsign(r,e);return ethUtil.bufferToHex(concatSig(n.v,n.r,n.s))}function recoverTypedSignature(e){const t=recoverPublicKey(TypedDataUtils.sign(e.data,!1),e.sig),r=ethUtil.publicToAddress(t);return ethUtil.bufferToHex(r)}function recoverTypedSignature_v4(e){const t=recoverPublicKey(TypedDataUtils.sign(e.data),e.sig),r=ethUtil.publicToAddress(t);return ethUtil.bufferToHex(r)}function typedSignatureHash(e){const t=new Error("Expect argument to be non-empty array");if("object"!=typeof e||!("length"in e)||!e.length)throw t;const r=e.map((function(e){return"bytes"===e.type?ethUtil.toBuffer(e.value):e.value})),n=e.map((function(e){return e.type})),i=e.map((function(e){if(!e.name)throw t;return`${e.type} ${e.name}`}));return ethAbi.soliditySHA3(["bytes32","bytes32"],[ethAbi.soliditySHA3(new Array(e.length).fill("string"),i),ethAbi.soliditySHA3(n,r)])}function recoverPublicKey(e,t){const r=ethUtil.toBuffer(t),n=ethUtil.fromRpcSig(r);return ethUtil.ecrecover(e,n.v,n.r,n.s)}function getPublicKeyFor(e){const t=ethUtil.toBuffer(e.data);return recoverPublicKey(ethUtil.hashPersonalMessage(t),e.sig)}function padWithZeroes(e,t){let r=""+e;for(;r.length<t;)r="0"+r;return r}function nacl_decodeHex(e){const t=Buffer.from(e,"hex").toString("base64");return naclUtil.decodeBase64(t)}exports.TypedDataUtils=TypedDataUtils,exports.concatSig=concatSig,exports.normalize=normalize,exports.personalSign=personalSign,exports.recoverPersonalSignature=recoverPersonalSignature,exports.extractPublicKey=extractPublicKey,exports.typedSignatureHash=externalTypedSignatureHash,exports.signTypedDataLegacy=signTypedDataLegacy,exports.recoverTypedSignatureLegacy=recoverTypedSignatureLegacy,exports.encrypt=encrypt,exports.encryptSafely=encryptSafely,exports.decrypt=decrypt,exports.decryptSafely=decryptSafely,exports.getEncryptionPublicKey=getEncryptionPublicKey,exports.signTypedMessage=signTypedMessage,exports.recoverTypedMessage=recoverTypedMessage,exports.signTypedData=signTypedData,exports.signTypedData_v4=signTypedData_v4,exports.recoverTypedSignature=recoverTypedSignature,exports.recoverTypedSignature_v4=recoverTypedSignature_v4;
//# sourceMappingURL=/sm/d9f97484021ee00fba6112910c75538169b2eab2cd4625286a4c5dc0c5a7e605.map